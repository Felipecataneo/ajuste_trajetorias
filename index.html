<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ¢Ô∏è An√°lise de Trajet√≥rias de Po√ßos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.29.1/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 700;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 5px;
            margin-bottom: 20px;
            backdrop-filter: blur(10px);
        }

        .tab {
            flex: 1;
            padding: 15px 20px;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            color: #555;
            border: 2px solid transparent;
        }

        .tab.active {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border-color: #667eea;
        }

        .tab-content {
            display: none;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            margin-bottom: 30px;
            transition: all 0.3s ease;
            background: rgba(102, 126, 234, 0.05);
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: rgba(118, 75, 162, 0.1);
            transform: translateY(-2px);
        }

        .upload-area.dragover {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        .btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.danger {
            background: linear-gradient(45deg, #dc3545, #c82333);
        }

        .btn.success {
            background: linear-gradient(45deg, #28a745, #20c997);
        }

        .input-group {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .input-group label {
            font-weight: 600;
            min-width: 100px;
        }

        .input-group input, .input-group select {
            padding: 10px 15px;
            border: 2px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            font-size: 14px;
            min-width: 120px;
            transition: all 0.3s ease;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .wells-list {
            background: rgba(102, 126, 234, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .well-item {
            background: white;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
        }

        .well-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            border-left: 5px solid;
        }

        .status.success {
            background: rgba(40, 167, 69, 0.1);
            border-color: #28a745;
            color: #155724;
        }

        .status.error {
            background: rgba(220, 53, 69, 0.1);
            border-color: #dc3545;
            color: #721c24;
        }

        .status.info {
            background: rgba(23, 162, 184, 0.1);
            border-color: #17a2b8;
            color: #0c5460;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
            
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
        }

        .card {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            margin-bottom: 20px;
        }

        .distances-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .distances-table th, .distances-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid rgba(102, 126, 234, 0.2);
        }

        .distances-table th {
            background: rgba(102, 126, 234, 0.1);
            font-weight: 600;
        }

        .coordinates-display {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            text-align: center;
            font-size: 1.2em;
            font-weight: 600;
            box-shadow: 0 4px 20px rgba(102, 126, 234, 0.3);
        }

        #plot3d, #planningPlot {
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üõ¢Ô∏è An√°lise de Trajet√≥rias de Po√ßos</h1>
            <p>Sistema de planejamento interativo com visualiza√ß√£o 3D, exclusivamente no frontend.</p>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="showTab('upload', this)">üìÅ Carregar Dados</div>
            <div class="tab" onclick="showTab('3d', this)">üó∫Ô∏è Visualiza√ß√£o 3D</div>
            <div class="tab" onclick="showTab('planning', this)">üéØ Planejamento</div>
        </div>

        <div id="upload-tab" class="tab-content active">
            <h2>üìä Carregamento de Dados</h2>
            
            <div class="upload-area" id="uploadArea">
                <h3>üìÅ Carregar Arquivos Excel</h3>
                <p>Arraste arquivos aqui ou clique para selecionar</p>
                <p><small>Suporte para m√∫ltiplos arquivos .xlsx e .xls</small></p>
                <input type="file" id="fileInput" multiple accept=".xlsx,.xls" style="display: none;">
            </div>

            <div class="input-group">
                <button class="btn" onclick="document.getElementById('fileInput').click()">
                    üóÇÔ∏è Selecionar Arquivos
                </button>
                <button class="btn danger" onclick="clearAllData()">
                    üóëÔ∏è Limpar Todos os Dados
                </button>
            </div>

            <div id="statusMessage"></div>

            <div id="wellsList" class="wells-list" style="display: none;">
                <h3>üìã Po√ßos Carregados</h3>
                <div id="wellsContainer"></div>
            </div>

            <div class="card">
                <h3>üìã Formato do Arquivo Excel</h3>
                <p>Cada arquivo deve conter dados de <strong>um √∫nico po√ßo</strong> com as colunas:</p>
                <table class="distances-table">
                    <thead><tr><th>Coluna</th><th>Descri√ß√£o</th><th>Unidade</th></tr></thead>
                    <tbody>
                        <tr><td><code>Well_Name</code></td><td>Nome do po√ßo</td><td>Texto</td></tr>
                        <tr><td><code>MD</code></td><td>Measured Depth</td><td>metros</td></tr>
                        <tr><td><code>INC</code></td><td>Inclina√ß√£o</td><td>graus</td></tr>
                        <tr><td><code>AZI</code></td><td>Azimute</td><td>graus</td></tr>
                        <tr><td><code>Head_North</code></td><td>Coordenada Norte da cabe√ßa</td><td>metros</td></tr>
                        <tr><td><code>Head_East</code></td><td>Coordenada Leste da cabe√ßa</td><td>metros</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <div id="3d-tab" class="tab-content">
            <h2>üó∫Ô∏è Visualiza√ß√£o 3D</h2>
            
            <div class="card">
                <h3>‚öôÔ∏è Controles</h3>
                <div class="input-group">
                    <label for="wellSelector">Po√ßos a exibir:</label>
                    <select id="wellSelector" multiple style="min-height: 100px; flex-grow: 1;"></select>
                </div>
                <div class="input-group">
                    <label>
                        <input type="checkbox" id="showDistances" checked onchange="update3DPlot()">
                        Mostrar dist√¢ncias entre cabe√ßas
                    </label>
                </div>
                <button class="btn" onclick="update3DPlot()">üîÑ Atualizar Visualiza√ß√£o</button>
            </div>

            <div class="card">
                <div id="plot3d" style="min-height: 600px;"></div>
            </div>

            <div id="distancesTableContainer" class="card" style="display: none;">
                <h3>üìè Dist√¢ncias entre Cabe√ßas dos Po√ßos</h3>
                <table class="distances-table">
                    <thead><tr><th>Po√ßo 1</th><th>Po√ßo 2</th><th>Dist√¢ncia (m)</th></tr></thead>
                    <tbody id="distancesTableBody"></tbody>
                </table>
            </div>
        </div>

        <div id="planning-tab" class="tab-content">
            <h2>üéØ Planejamento Interativo</h2>
            
            <div class="status info">
                üí° <strong>Como usar:</strong> Passe o mouse sobre o gr√°fico para ver coordenadas e <strong>clique em qualquer ponto</strong> para definir a nova cabe√ßa de po√ßo.
            </div>

            <div class="grid">
                <div class="card">
                    <h3>üìç Inserir Coordenadas Manualmente</h3>
                    <div class="input-group"><label for="manualNorth">North (m):</label><input type="number" id="manualNorth" step="1" value="0"></div>
                    <div class="input-group"><label for="manualEast">East (m):</label><input type="number" id="manualEast" step="1" value="0"></div>
                    <button class="btn success" onclick="setManualWellhead()">‚úÖ Definir Nova Cabe√ßa</button>
                </div>

                <div class="card">
                    <h3>üìê Posi√ß√£o Relativa a Po√ßo</h3>
                    <div class="input-group"><label for="refWellSelect">Refer√™ncia:</label><select id="refWellSelect" onchange="updateRelativePreview()"></select></div>
                    <div class="input-group"><label for="offsetNorth">Offset North (m):</label><input type="number" id="offsetNorth" step="10" value="100" oninput="updateRelativePreview()"></div>
                    <div class="input-group"><label for="offsetEast">Offset East (m):</label><input type="number" id="offsetEast" step="10" value="100" oninput="updateRelativePreview()"></div>
                    <div id="previewCoords" class="status info" style="display: none;"></div>
                    <button class="btn success" onclick="setRelativeWellhead()">‚úÖ Confirmar Posi√ß√£o</button>
                </div>
            </div>

            <div class="card">
                <div id="planningPlot" style="min-height: 600px;"></div>
            </div>

            <div id="newWellheadInfo" style="display: none;">
                <div class="coordinates-display">üéØ Nova Cabe√ßa: <span id="newWellheadCoords"></span></div>

                <div class="grid">
                    <div class="card">
                        <h3>üîß Ajuste Fino</h3>
                        <div class="input-group"><label for="adjustNorth">North (m):</label><input type="number" id="adjustNorth" step="1"></div>
                        <div class="input-group"><label for="adjustEast">East (m):</label><input type="number" id="adjustEast" step="1"></div>
                        <button class="btn" onclick="adjustWellhead()">üîÑ Ajustar Posi√ß√£o</button>
                    </div>

                    <div class="card">
                        <h3>üìè Ajuste por Dist√¢ncia</h3>
                        <div class="input-group"><label for="distRefWell">Refer√™ncia:</label><select id="distRefWell" onchange="updateCurrentDistance()"></select></div>
                        <div class="input-group"><label>Dist√¢ncia atual:</label><strong id="currentDistance" style="font-size: 1.1em;">-</strong></div>
                        <div class="input-group"><label for="targetDistance">Dist. desejada (m):</label><input type="number" id="targetDistance" step="10"></div>
                        <button class="btn" onclick="adjustByDistance()">üìè Ajustar por Dist√¢ncia</button>
                    </div>
                </div>

                <div class="card">
                    <h3>üìè Dist√¢ncias para Po√ßos Existentes</h3>
                    <table class="distances-table">
                        <thead><tr><th>Po√ßo</th><th>Dist√¢ncia (m)</th></tr></thead>
                        <tbody id="newWellDistances"></tbody>
                    </table>
                </div>

                <div class="input-group" style="justify-content: center;">
                    <button class="btn success" onclick="exportCoordinates()">üíæ Copiar Coordenadas</button>
                    <button class="btn danger" onclick="clearNewWellhead()">üóëÔ∏è Limpar Nova Cabe√ßa</button>
                </div>
            </div>
        </div>
    </div>

<script>
    // ========================================================
    // 1. VARI√ÅVEIS GLOBAIS E ESTADO DA APLICA√á√ÉO
    // ========================================================
    let wellsData = {};
    let newWellhead = null;
    const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#e67e22', '#1abc9c', '#34495e'];

    // ========================================================
    // 2. FUN√á√ïES DE C√ÅLCULO (Tradu√ß√£o direta do Python)
    // ========================================================
    function calculateSurveyCoords(md, inc, azi, startTvd = 0, startNorth = 0, startEast = 0) {
        const n = md.length;
        const tvd = new Array(n), north = new Array(n), east = new Array(n), dogleg = new Array(n);

        tvd[0] = startTvd;
        north[0] = startNorth;
        east[0] = startEast;
        dogleg[0] = 0;

        const toRad = deg => deg * Math.PI / 180;
        const incRad = inc.map(toRad);
        const aziRad = azi.map(toRad);

        for (let i = 1; i < n; i++) {
            const deltaMd = md[i] - md[i-1];
            if (deltaMd <= 1e-6) {
                tvd[i] = tvd[i-1];
                north[i] = north[i-1];
                east[i] = east[i-1];
                dogleg[i] = dogleg[i-1];
                continue;
            }

            const dogleggRad = Math.acos(
                Math.cos(incRad[i] - incRad[i-1]) -
                Math.sin(incRad[i-1]) * Math.sin(incRad[i]) *
                (1 - Math.cos(aziRad[i] - aziRad[i-1]))
            );

            dogleg[i] = (dogleggRad * 180 / Math.PI) * 30 / deltaMd;
            let rf = (dogleggRad > 1e-6) ? (2 / dogleggRad) * Math.tan(dogleggRad / 2) : 1.0;

            const deltaTvd = (deltaMd / 2) * (Math.cos(incRad[i-1]) + Math.cos(incRad[i])) * rf;
            const deltaNorth = (deltaMd / 2) * (Math.sin(incRad[i-1]) * Math.cos(aziRad[i-1]) + Math.sin(incRad[i]) * Math.cos(aziRad[i])) * rf;
            const deltaEast = (deltaMd / 2) * (Math.sin(incRad[i-1]) * Math.sin(aziRad[i-1]) + Math.sin(incRad[i]) * Math.sin(aziRad[i])) * rf;

            tvd[i] = tvd[i-1] + deltaTvd;
            north[i] = north[i-1] + deltaNorth;
            east[i] = east[i-1] + deltaEast;
        }
        return { tvd, north, east, dogleg };
    }

    function calculateDistance(north1, east1, north2, east2) {
        return Math.sqrt(Math.pow(north1 - north2, 2) + Math.pow(east1 - east2, 2));
    }

    function calculateNewPositionFromDistance(refNorth, refEast, targetDistance, currentNorth, currentEast) {
        const currentDist = calculateDistance(refNorth, refEast, currentNorth, currentEast);
        if (currentDist === 0) return { north: refNorth + targetDistance, east: refEast };
        
        const scale = targetDistance / currentDist;
        const newNorth = refNorth + (currentNorth - refNorth) * scale;
        const newEast = refEast + (currentEast - refEast) * scale;
        return { north: newNorth, east: newEast };
    }

    // ========================================================
    // 3. MANIPULA√á√ÉO DA INTERFACE (UI)
    // ========================================================
    function showTab(tabName, element) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
        
        element.classList.add('active');
        document.getElementById(`${tabName}-tab`).classList.add('active');
        
        // Redesenha os gr√°ficos quando a aba se torna vis√≠vel para evitar problemas de dimensionamento
        if (tabName === '3d') {
            setTimeout(update3DPlot, 10);
        } else if (tabName === 'planning') {
            setTimeout(updatePlanningPlot, 10);
        }
    }

    function showStatus(message, type = 'info', duration = 5000) {
        const statusDiv = document.getElementById('statusMessage');
        statusDiv.className = `status ${type}`;
        statusDiv.innerHTML = message;
        statusDiv.style.display = 'block';
        setTimeout(() => { statusDiv.style.display = 'none'; }, duration);
    }
    
    // ========================================================
    // 4. L√ìGICA DE CARREGAMENTO E PROCESSAMENTO DE ARQUIVOS
    // ========================================================
    document.addEventListener('DOMContentLoaded', () => {
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('click', () => fileInput.click());
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            uploadArea.addEventListener(eventName, e => {
                e.preventDefault();
                e.stopPropagation();
            });
        });
        uploadArea.addEventListener('dragover', () => uploadArea.classList.add('dragover'));
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', e => {
            uploadArea.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });
        fileInput.addEventListener('change', e => handleFiles(e.target.files));
    });

    function handleFiles(files) {
        if (!files.length) return;
        showStatus('‚è≥ Processando arquivos...', 'info');
        Array.from(files).forEach(file => {
            if (file.name.toLowerCase().endsWith('.xlsx') || file.name.toLowerCase().endsWith('.xls')) {
                processExcelFile(file);
            } else {
                showStatus(`‚ùå Arquivo ${file.name} n√£o √© um Excel v√°lido.`, 'error');
            }
        });
    }

    function processExcelFile(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const workbook = XLSX.read(e.target.result, { type: 'binary' });
                const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                const data = XLSX.utils.sheet_to_json(worksheet);

                if (!data.length) throw new Error("O arquivo est√° vazio.");
                
                const requiredCols = ['Well_Name', 'MD', 'INC', 'AZI', 'Head_North', 'Head_East'];
                const missingCols = requiredCols.filter(col => !(col in data[0]));
                if (missingCols.length > 0) throw new Error(`Colunas faltando: ${missingCols.join(', ')}`);

                const fileName = file.name.split('.')[0];
                const wellName = data[0].Well_Name;
                let uniqueWellName = `${wellName} (${fileName})`;
                let counter = 1;
                while (wellsData[uniqueWellName]) {
                    uniqueWellName = `${wellName} (${fileName})_${counter++}`;
                }

                const sortedData = data.sort((a, b) => a.MD - b.MD);
                const coords = calculateSurveyCoords(
                    sortedData.map(r => r.MD),
                    sortedData.map(r => r.INC),
                    sortedData.map(r => r.AZI),
                    0,
                    sortedData[0].Head_North,
                    sortedData[0].Head_East
                );

                wellsData[uniqueWellName] = {
                    MD: sortedData.map(r => r.MD), INC: sortedData.map(r => r.INC), AZI: sortedData.map(r => r.AZI),
                    TVD: coords.tvd, North: coords.north, East: coords.east, Dogleg: coords.dogleg
                };
                showStatus(`‚úÖ Po√ßo '${uniqueWellName}' carregado!`, 'success');
            } catch (error) {
                showStatus(`‚ùå Erro em ${file.name}: ${error.message}`, 'error');
            }
            // Atualiza a UI ap√≥s o processamento do √∫ltimo arquivo
            updateFullUI();
        };
        reader.readAsBinaryString(file);
    }

    function removeWell(wellName) {
        if (confirm(`Tem certeza que deseja remover o po√ßo "${wellName}"?`)) {
            delete wellsData[wellName];
            showStatus(`üóëÔ∏è Po√ßo '${wellName}' removido.`, 'success');
            updateFullUI();
        }
    }

    function clearAllData() {
        if (confirm("Tem certeza que deseja limpar todos os dados? Esta a√ß√£o n√£o pode ser desfeita.")) {
            wellsData = {};
            newWellhead = null;
            showStatus('üóëÔ∏è Todos os dados foram limpos!', 'success');
            updateFullUI();
        }
    }
    
    // ========================================================
    // 5. FUN√á√ïES DE ATUALIZA√á√ÉO DA UI (Listas, Gr√°ficos, etc.)
    // ========================================================

    function updateFullUI() {
        updateWellsList();
        updateSelectors();
        update3DPlot();
        updatePlanningPlot();
        updateNewWellheadSection();
    }

    function updateWellsList() {
        const container = document.getElementById('wellsContainer');
        const listDiv = document.getElementById('wellsList');
        const wellNames = Object.keys(wellsData);

        container.innerHTML = '';
        if (wellNames.length === 0) {
            listDiv.style.display = 'none';
            return;
        }
        
        listDiv.style.display = 'block';
        wellNames.forEach((name, i) => {
            const item = document.createElement('div');
            item.className = 'well-item';
            item.innerHTML = `<span><b style="color:${colors[wellNames.indexOf(name) % colors.length]};">‚óè</b> ${name}</span>
                              <button class="btn danger" style="padding: 5px 10px;" onclick="removeWell('${name}')">Remover</button>`;
            container.appendChild(item);
        });
    }

    function updateSelectors() {
        const selectors = ['wellSelector', 'refWellSelect', 'distRefWell'];
        const wellNames = Object.keys(wellsData);
        selectors.forEach(id => {
            const select = document.getElementById(id);
            const isMultiSelect = select.multiple;
            const selectedValues = isMultiSelect ? Array.from(select.selectedOptions).map(opt => opt.value) : [select.value];
            
            select.innerHTML = '';
            wellNames.forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                if (isMultiSelect) {
                    option.selected = selectedValues.length === 0 || selectedValues.includes(name);
                } else if (selectedValues.includes(name)) {
                    option.selected = true;
                }
                select.appendChild(option);
            });
        });
        updateRelativePreview();
    }
    
    // ========================================================
    // 6. L√ìGICA DE PLOTAGEM (3D e Planejamento)
    // ========================================================

    function update3DPlot() {
        const plotDiv = document.getElementById('plot3d');
        const selectedWells = Array.from(document.getElementById('wellSelector').selectedOptions).map(opt => opt.value);
        const traces = [];

        if (selectedWells.length === 0) {
            Plotly.purge(plotDiv);
            plotDiv.innerHTML = '<div class="status info">Selecione um ou mais po√ßos para visualizar.</div>';
            document.getElementById('distancesTableContainer').style.display = 'none';
            return;
        }

        selectedWells.forEach((name, i) => {
            const data = wellsData[name];
            const color = colors[i % colors.length];
            // Trajet√≥ria
            traces.push({
                x: data.East, y: data.North, z: data.TVD.map(v => -v),
                mode: 'lines', type: 'scatter3d', name: `${name}`,
                line: { color: color, width: 5 },
                hovertemplate: `<b>${name}</b><br>East: %{x:.1f} m<br>North: %{y:.1f} m<br>-TVD: %{z:.1f} m<extra></extra>`
            });
            // Cabe√ßa do po√ßo
            traces.push({
                x: [data.East[0]], y: [data.North[0]], z: [-data.TVD[0]],
                mode: 'markers', type: 'scatter3d', name: `${name} - Cabe√ßa`,
                marker: { color: color, size: 8, symbol: 'diamond' },
                showlegend: false,
                hovertemplate: `<b>${name} - Cabe√ßa</b><br>East: %{x:.1f} m<br>North: %{y:.1f} m<extra></extra>`
            });
        });

        const layout = {
            title: 'Visualiza√ß√£o 3D das Trajet√≥rias',
            scene: {
                xaxis: { title: 'East (m)' },
                yaxis: { title: 'North (m)' },
                zaxis: { title: '-TVD (m)' },
                aspectmode: 'data' // Mant√©m a propor√ß√£o real dos eixos
            },
            margin: { l: 0, r: 0, b: 0, t: 40 },
            legend: { orientation: 'h', yanchor: 'top', y: 1 }
        };

        Plotly.newPlot(plotDiv, traces, layout, {responsive: true});
        updateHeadDistancesTable(selectedWells);
    }

    function updateHeadDistancesTable(selectedWells) {
        const tableBody = document.getElementById('distancesTableBody');
        const tableContainer = document.getElementById('distancesTableContainer');
        const show = document.getElementById('showDistances').checked;
        tableBody.innerHTML = '';

        if (!show || selectedWells.length < 2) {
            tableContainer.style.display = 'none';
            return;
        }

        tableContainer.style.display = 'block';
        for (let i = 0; i < selectedWells.length; i++) {
            for (let j = i + 1; j < selectedWells.length; j++) {
                const well1 = selectedWells[i];
                const well2 = selectedWells[j];
                const head1 = wellsData[well1];
                const head2 = wellsData[well2];
                const dist = calculateDistance(head1.North[0], head1.East[0], head2.North[0], head2.East[0]);
                
                const row = tableBody.insertRow();
                row.innerHTML = `<td>${well1}</td><td>${well2}</td><td>${dist.toFixed(1)}</td>`;
            }
        }
    }

        function updatePlanningPlot() {
            const plotDiv = document.getElementById('planningPlot');
            const traces = [];
            const wellNames = Object.keys(wellsData);

            // Adiciona po√ßos existentes
            wellNames.forEach((name, i) => {
                const data = wellsData[name];
                const color = colors[i % colors.length];
                traces.push({ // Trajet√≥ria
                    x: data.East, y: data.North, mode: 'lines', name: name, line: { color, width: 3 },
                    hovertemplate: `<b>${name}</b><br>North: %{y:.1f}<br>East: %{x:.1f}<extra></extra>`
                });
                traces.push({ // Cabe√ßa
                    x: [data.East[0]], y: [data.North[0]], mode: 'markers+text', name: `${name} - Cabe√ßa`,
                    marker: { color, size: 12, symbol: 'diamond' }, text: [name.split('(')[0]], textposition: 'top center',
                    showlegend: false, hoverinfo: 'skip'
                });
            });

            // Adiciona nova cabe√ßa, se definida
            if (newWellhead) {
                traces.push({
                    x: [newWellhead.east], y: [newWellhead.north], mode: 'markers+text', name: 'Nova Cabe√ßa',
                    marker: { color: 'red', size: 16, symbol: 'star' }, text: ['NOVA'], textposition: 'top center',
                    hovertemplate: '<b>Nova Cabe√ßa</b><br>North: %{y:.1f}<br>East: %{x:.1f}<extra></extra>'
                });
            }
            
            const layout = {
                title: 'Vista de Topo - Clique para posicionar nova cabe√ßa',
                xaxis: { title: 'East (m)', zeroline: false },
                yaxis: { title: 'North (m)', scaleanchor: 'x', scaleratio: 1, zeroline: false },
                hovermode: 'closest',
                showlegend: true,
                legend: { orientation: 'h', yanchor: 'bottom', y: 1.02 },
                margin: { l: 60, r: 20, b: 50, t: 80 }
            };

            Plotly.newPlot(plotDiv, traces, layout, {responsive: true}).then(gd => {
                // Remove qualquer listener de clique antigo para evitar duplica√ß√£o
                gd.removeEventListener('click', window.handlePlotClick);

                // Define uma fun√ß√£o nomeada para que possamos remov√™-la mais tarde
                window.handlePlotClick = (event) => {
                    // Get a refer√™ncia para o layout atualizado do gr√°fico
                    const fullLayout = gd._fullLayout;
                    if (!fullLayout || !fullLayout.xaxis || !fullLayout.yaxis) return;

                    const xaxis = fullLayout.xaxis;
                    const yaxis = fullLayout.yaxis;
                    
                    // Pega as coordenadas do clique relativas √† div do gr√°fico
                    const rect = gd.getBoundingClientRect();
                    const clickX = event.clientX - rect.left;
                    const clickY = event.clientY - rect.top;

                    // Dimens√µes e posi√ß√£o da √°rea de plotagem (descontando margens e t√≠tulos)
                    const plotAreaXStart = xaxis._offset;
                    const plotAreaYStart = yaxis._offset;
                    const plotAreaWidth = xaxis._length;
                    const plotAreaHeight = yaxis._length;
                    
                    // Verifica se o clique ocorreu dentro da √°rea de plotagem
                    if (clickX >= plotAreaXStart && clickX <= plotAreaXStart + plotAreaWidth &&
                        clickY >= plotAreaYStart && clickY <= plotAreaYStart + plotAreaHeight) {

                        // Calcula a posi√ß√£o do clique como uma fra√ß√£o (0 a 1) dentro da √°rea de plotagem
                        const xFraction = (clickX - plotAreaXStart) / plotAreaWidth;
                        const yFraction = (clickY - plotAreaYStart) / plotAreaHeight;
                        
                        // Pega o intervalo de dados vis√≠vel nos eixos
                        const eastRange = xaxis.range;
                        const northRange = yaxis.range;
                        
                        // Converte as fra√ß√µes em coordenadas de dados
                        const east = eastRange[0] + xFraction * (eastRange[1] - eastRange[0]);
                        // Para o eixo Y, a coordenada de pixel √© invertida (0 √© no topo)
                        const north = northRange[1] - yFraction * (northRange[1] - northRange[0]);

                        newWellhead = { north: north, east: east };
                        showStatus(`üéØ Nova cabe√ßa definida em N: ${north.toFixed(1)}, E: ${east.toFixed(1)}`, 'success');
                        updateFullUI(); // Redesenha tudo com a nova cabe√ßa
                    }
                };

                // Adiciona o listener de clique ao elemento do gr√°fico
                gd.addEventListener('click', window.handlePlotClick);
            });
    }

    // ========================================================
    // 7. L√ìGICA DE PLANEJAMENTO INTERATIVO
    // ========================================================
    function setManualWellhead() {
        const north = parseFloat(document.getElementById('manualNorth').value);
        const east = parseFloat(document.getElementById('manualEast').value);
        newWellhead = { north, east };
        showStatus(`‚úÖ Nova cabe√ßa definida manualmente.`, 'success');
        updateFullUI();
    }

    function updateRelativePreview() {
        const refWellName = document.getElementById('refWellSelect').value;
        if (!refWellName) {
            document.getElementById('previewCoords').style.display = 'none';
            return;
        }
        const refHead = wellsData[refWellName];
        const offsetN = parseFloat(document.getElementById('offsetNorth').value) || 0;
        const offsetE = parseFloat(document.getElementById('offsetEast').value) || 0;
        const previewN = refHead.North[0] + offsetN;
        const previewE = refHead.East[0] + offsetE;
        
        const previewDiv = document.getElementById('previewCoords');
        previewDiv.innerHTML = `üìç Preview: North=${previewN.toFixed(1)}, East=${previewE.toFixed(1)}`;
        previewDiv.style.display = 'block';
    }

    function setRelativeWellhead() {
        const refWellName = document.getElementById('refWellSelect').value;
        if (!refWellName) {
            showStatus('‚ùå Selecione um po√ßo de refer√™ncia primeiro.', 'error');
            return;
        }
        const refHead = wellsData[refWellName];
        const offsetN = parseFloat(document.getElementById('offsetNorth').value) || 0;
        const offsetE = parseFloat(document.getElementById('offsetEast').value) || 0;
        newWellhead = { north: refHead.North[0] + offsetN, east: refHead.East[0] + offsetE };
        showStatus(`‚úÖ Nova cabe√ßa definida por posi√ß√£o relativa.`, 'success');
        updateFullUI();
    }

    function updateNewWellheadSection() {
        const section = document.getElementById('newWellheadInfo');
        if (!newWellhead) {
            section.style.display = 'none';
            return;
        }
        section.style.display = 'block';

        // Atualiza display principal e inputs de ajuste
        document.getElementById('newWellheadCoords').textContent = `N: ${newWellhead.north.toFixed(1)}, E: ${newWellhead.east.toFixed(1)}`;
        document.getElementById('adjustNorth').value = newWellhead.north.toFixed(1);
        document.getElementById('adjustEast').value = newWellhead.east.toFixed(1);

        // Atualiza tabela de dist√¢ncias
        const tableBody = document.getElementById('newWellDistances');
        tableBody.innerHTML = '';
        Object.keys(wellsData).forEach(name => {
            const head = wellsData[name];
            const dist = calculateDistance(head.North[0], head.East[0], newWellhead.north, newWellhead.east);
            const row = tableBody.insertRow();
            row.innerHTML = `<td>${name}</td><td>${dist.toFixed(1)} m</td>`;
        });
        
        updateCurrentDistance();
    }
    
    function adjustWellhead() {
        const north = parseFloat(document.getElementById('adjustNorth').value);
        const east = parseFloat(document.getElementById('adjustEast').value);
        newWellhead = { north, east };
        showStatus('‚úÖ Posi√ß√£o da nova cabe√ßa ajustada.', 'success');
        updateFullUI();
    }
    
    function updateCurrentDistance() {
        const refWellName = document.getElementById('distRefWell').value;
        if (!refWellName || !newWellhead) {
            document.getElementById('currentDistance').textContent = '-';
            return;
        };
        const refHead = wellsData[refWellName];
        const dist = calculateDistance(refHead.North[0], refHead.East[0], newWellhead.north, newWellhead.east);
        document.getElementById('currentDistance').textContent = `${dist.toFixed(1)} m`;
        document.getElementById('targetDistance').value = dist.toFixed(1);
    }
    
    function adjustByDistance() {
        const refWellName = document.getElementById('distRefWell').value;
        if (!refWellName) {
            showStatus('‚ùå Selecione um po√ßo de refer√™ncia para o ajuste de dist√¢ncia.', 'error');
            return;
        }
        const refHead = wellsData[refWellName];
        const targetDist = parseFloat(document.getElementById('targetDistance').value);
        
        const { north, east } = calculateNewPositionFromDistance(
            refHead.North[0], refHead.East[0], targetDist, newWellhead.north, newWellhead.east
        );
        newWellhead = { north, east };
        showStatus('‚úÖ Posi√ß√£o ajustada pela dist√¢ncia desejada.', 'success');
        updateFullUI();
    }
    
    function clearNewWellhead() {
        if (confirm("Tem certeza que deseja limpar a nova cabe√ßa planejada?")) {
            newWellhead = null;
            showStatus('üóëÔ∏è Nova cabe√ßa limpa.', 'info');
            updateFullUI();
        }
    }

    function exportCoordinates() {
        if (!newWellhead) return;
        const textToCopy = `North: ${newWellhead.north.toFixed(1)}\nEast: ${newWellhead.east.toFixed(1)}`;
        navigator.clipboard.writeText(textToCopy).then(() => {
            showStatus('‚úÖ Coordenadas copiadas para a √°rea de transfer√™ncia!', 'success');
        }, () => {
            showStatus('‚ùå Falha ao copiar coordenadas.', 'error');
        });
    }

</script>
</body>
</html>
